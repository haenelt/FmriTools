# -*- coding: utf-8 -*-
"""Surface smoothing."""

import os
import uuid

import nibabel as nb

from .. import execute_command
from ..io.filename import get_filename

__all__ = ["prepare_fieldmap_fsl", "fugue_fsl", "apply_fieldmap"]


def _bids_to_cardinal(pe_dir: str) -> str:
    """Convert BIDS PE dir (i, i-, j, j-, k, k-) to AP/PA/RL/LR/SI/IS."""
    pe = pe_dir.strip().lower()

    mapping = {
        "i": "RL",
        "i-": "LR",
        "j": "AP",
        "j-": "PA",
        "k": "SI",
        "k-": "IS",
    }

    # np-style: use dict lookup with fallback to upper()
    return mapping.get(pe, pe.upper())


def _pe_axis_from_cardinal(pe_dir: str) -> int:
    """Get axis of phase-encoding direction."""
    axis_map = {
        "RL": 0,
        "LR": 0,
        "AP": 1,
        "PA": 1,
        "SI": 2,
        "IS": 2,
    }
    return axis_map[pe_dir]


def prepare_fieldmap_fsl(file_magn, file_phase, file_out, delta_te):
    """Create fieldmap from siemens phase difference image using FSL.

    Parameters
    ----------
    file_magn : str
        File name of magnitude image (take first echo).
    file_phase : str
        File name of phase differene image.
    file_out : str
        File name of fieldmap image (in rad/s).
    delta_te : float
        Delta TE in ms.
    """
    # make output folder
    path_out, _, _ = get_filename(file_out)
    if not os.path.exists(path_out):
        os.makedirs(path_out)

    command = "fsl_prepare_fieldmap SIEMENS"
    command += f" {file_phase}"
    command += f" {file_magn}"
    command += f" {file_out}"
    command += f" {delta_te:.6f}"

    # run
    execute_command(command)


def fugue_fsl(file_in, file_fmap, file_shift, dwell_time, gaussian_sigma, udir):
    """Unwarp image based on field map. The unwarped input file is saved in the same
    directory.

    Parameters
    ----------
    file_in : str
        File name of input image.
    file_fmap : str
        File name of field map (in rad/s).
    file_shift : str
        File name of output image containing applied shift.
    dwell_time : float
        Dwell time (in s).
    gaussian_sigma : float
        Apply Gaussian smoothing of sigma (in mm).
    udir : str
        Unwarping direction (x, y, z, x-, y-, or z-).
    """
    # output file name
    _, name_in, ext_in = get_filename(file_in)

    # make output folder
    path_out, _, _ = get_filename(file_shift)
    if not os.path.exists(path_out):
        os.makedirs(path_out)

    command = "fugue"
    command += f" --dwell={dwell_time:.10f}"
    command += f" --loadfmap={file_fmap}"
    command += f" --in={file_in}"
    command += f" --saveshift={file_shift}"
    command += f" --smooth3={gaussian_sigma:.2f}"
    command += f" --unwarpdir={udir}"
    command += f" --unwarp={name_in}_unwarped{ext_in}"

    # run
    execute_command(command)


def apply_fieldmap(
    file_in: str,
    file_out: str,
    file_shift: str,
    pe_dir: str,
    file_moco: str | None = None,
    deoblique: bool = True,
):
    """Applies a computed shift map from fugue to a data set. The main purpose of this
    function is to combine both transformations from afnis's motion correction with the
    field map undistortion to only apply one spatial resampling.

    Parameters
    ----------
    file_in : str
        File name of input image.
    file_out : str
        File name of output image.
    file_shift : str
        File name of shift map in voxel units.
    pe_dir : float
        Phase-encoding direction (AP, PA, RL, LR, IS, SI) or in BIDS format (i, i-, j,
        j-, k, k-)..
    file_moco : float
        File name of the motion-correction file containing the affine transformation
        for each volume. This file is generated by running 3dvolreg with the
        `-1dmatrix_save` option.
    deoblique : str
        Deoblique shift map. This will be only applied to a generated temporary file.
        The shift map itself stays untouched.
    """
    # make output folder
    path_out, _, _ = get_filename(file_out)
    if not os.path.exists(path_out):
        os.makedirs(path_out)

    _, _, ext_shift = get_filename(file_shift)
    file_shift_temp = os.path.join(path_out, f"{uuid.uuid4()}{ext_shift}")

    # get phase encoding direction and voxel size
    pe_dir = _bids_to_cardinal(pe_dir)
    axis = _pe_axis_from_cardinal(pe_dir)
    voxel_size = nb.load(file_in).header.get_zooms()[axis]

    # overwrite dataset as afni saves data
    command = "3dcopy"
    command += f" {file_shift}"
    command += f" {file_shift_temp}"

    # run
    execute_command(command)

    # deoblique shift map
    if deoblique:
        command = "3drefit"
        command += f" -deoblique {file_shift_temp}"

        execute_command(command)

    # scale shift map with voxel size
    shift = nb.load(file_shift_temp)
    arr_shift = shift.get_fdata() * voxel_size
    output = nb.Nifti1Image(arr_shift, shift.affine, shift.header)
    nb.save(output, file_shift_temp)

    warp_cmd = f"{pe_dir}:{file_shift_temp}"
    if file_moco:
        warp_cmd += f" {file_moco}"

    command = "3dNwarpApply"
    command += f" -source {file_in}"
    command += f" -master {file_in}"
    command += f" -nwarp {warp_cmd}"
    command += " -interp wsinc5"
    command += f" -prefix {file_out}"
    command += " -verb"

    execute_command(command)

    # Remove temporary shift map file
    os.remove(file_shift_temp)
